### 并发控制算法


减少锁的并发量




死锁deadlock 
活锁 livelock



### 死锁
线程间相互等待资源，但是没有一个线程可以进行下一步操作

饥饿 
因为某种原因导致线程得不到需要的资源，无法继续工作


### 基本条件
1. 资源存在互斥逻辑
2. 持有等待
3. 禁止抢占
4. 循环等待


#### 饥饿

长时间获取不到资源


```shell
var lock = new ReentrantLock();
lock.ttryLock(5, TimeUnit.SECONDS);
```


所有线程都工作， 但是没有线程能够进一步解决问题

活锁：
靠概率解决



### 解决
1. 排队
2. 同时拿两个叉子






### 什么情况下会触发饥饿和死锁
线程需要资源没有拿到，无法进行下一步，就是饥饿，
死锁和活锁都是饥饿的一种形式，非抢占的系统中，互斥的资源获取，形成循环依赖就会产生死锁



