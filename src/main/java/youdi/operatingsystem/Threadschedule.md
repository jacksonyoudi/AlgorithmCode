### 线程调度



#### FIFO

先到先服务
 算法非常朴素


优点：
    不会发生切换，资源浪费少
从吞吐量上看，是最优的， 没有额外开销



最短作业优先(shortest job First, SJF)

作业到来的时间顺序和执行预估的时间
平均等待时间

1。 紧急任务如何插队
2. 等待太久的任务如何插队
3. 先执行的大任务导致后面来的小任务没有执行如何处理


### 解决方案
优先级队列
抢占



PriorityQueue
给队列中每个元素一个优先级，优先级越高的任务就会被先执行

heap：
o(1)


w/p  等待时间/预估执行时间



### 抢占
把执行能力分时，分成时间片
让每个任务都执行一个时间片段



如果一个线程的优先级特别高， 其实没有必要再抢占，无论如何，下个时间片还是给它
如果希望实现最短作业优先的抢占，就必须知道每个线程的执行时间，这个时间是不可预估的

### 多级队列模型


低优先队列：
    考虑抢占+ 优先级队列的方式实现

高优先级队列：
    考虑用 非抢占(每个任务执行完才执行下一个) + 优先级队列实现



时间片不同，为了预估时间

![NrbApt](https://raw.githubusercontent.com/jacksonyoudi/images/main/uPic/NrbApt.png)






线程调度： 

1. FIFO
2. SFJ
3. 优先级队列
4. 时间片 抢占
5. 多级队列 + 细分时间片 + 实现预估时间




抢占的先到先服务的模型是最朴素的，公平性和吞吐量可以保证。
但是因为希望减少用户的平均等待时间，操作系统往往需要实现抢占。
操作系统实现抢占，仍然希望有优先级，希望有最短任务优先。

但是这里有个困难，操作系统无法预判每个任务的预估执行时间，
就需要使用分级队列。
最高优先级的任务可以考虑非抢占的优先级队列。 
其他任务放到分级队列模型中执行，从最高优先级时间片段最小向最低优先级时间片段最大逐渐沉淀。
这样就同时保证了小任务先行和高优任务最先执行。


模拟分级队列调度模型

