### B树和B+树的数据结构

### 行存储和列存储
row 
column


### 行
单条数据集中
查询慢，支持事务


### 列

适合计算 聚合
查询和聚合运算


### 索引
如何创建高效的索引

二分查找： 进步机制

设计冗余的数据描述排序信息

空间换时间

索引条目

行存储：

    * 如果有多个索引，就需要创造多个数据结构
    * 如果有复合索引，比如，a,b, c 作为一个索引条目
    * 复合索引，无非就是多消耗一些空间，排序维度多一些
    * 复合索引和单列索引完全是独立关系
    每创造一组索引，就创造一份冗余的数据


应不应该使用这种从小到达的排序的索引？


### 二叉搜索树
如果内存操作，插入一个元素，元素后面的元素都要往后偏移移位，这个就是灾难的


在使用磁盘的时候， 二叉树搜索树是不是一个很合理的查询结构？

不是，二叉搜索树，在内存中是一个高效的数据结构，这是因为内存速度快，不但可以随机存取，还可以高频操作。

二叉搜索树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点。
而且，因为索引条目较少，确实可以考虑在查询的时候，先将足够大的树导入内存，然后再进行搜索。
搜索的算法是递归的，与二分查找非常类似，每次计算可以将问题规模减半。
当然，具体有多少数据可以导入内存，受实际可以使用的内存数量的限制。

但是，这个逻辑在磁盘中是不存在的，磁盘的速度慢太多了。
我们可以尝试把尽可能多的二叉搜索树读入磁盘，但是如果数据量大，只能读入一部分呢？
因此我们还需要继续改进算法。



### B树和B+树
一个更好的方案： 继续沿用树的结构，利用好磁盘的分块，让每个节点多一些数据，并且允许子节点也多一些，树就会更矮


3-4索引


### B+数
只有叶子节点才保存数据


### 插入
过载， 上浮

### 插入和删除效率

插入
B+树 有大量的冗余节点
B树 没有冗余节点

删除
B+ 有冗余节点，插入可能存在节点的拆分
B树 没有冗余节点




### 搜索： 链表的作用

搜索原理基本一致

先从跟节点查找，然后对比目标数据范围，最后递归的进入子节点查找


总结：

* 如果是存储海量数据的数据库， 需要放在IO的效率上
* 如果把今天的知识放在分布式数据库上，处理需要节省磁盘读写还需要节省网络IO



B+ 树继承于 B 树，都限定了节点中数据数目和子节点的数目。
B 树所有节点都可以映射数据，B+ 树只有叶子节点可以映射数据。

单独看这部分设计，看不出 B+ 树的优势。为了只有叶子节点可以映射数据，
B+ 树创造了很多冗余的索引（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，而且可以自动平衡，因此 B+ 树的所有叶子节点总是在一个层级上。
所以 B+ 树可以用一条链表串联所有的叶子节点，也就是索引数据，这让 B+ 树的范围查找和聚合运算更快。
