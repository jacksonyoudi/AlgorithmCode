### 计算能源

摩尔定律

电路 => 芯片 => 计算

计算或者程序可以做什么？

希尔伯特


公理化体系
不完备性定理


图灵机

可计算理论


停机问题


计算消耗
时间开销+空间开销


### 问题边界

P与NP问题
问题不能在多项式时间内解决，就是NP问题





### 人工智能
图灵测试

芯片
摩尔定律
图灵机
图灵测试和人工智能





###  相比32位 64位的优势？

图灵机的构造：

1. 它定义了计算机能力的边界，也就是可计算理论
2. 它定义了计算机由哪些部分组成，程序又是如何执行的



状态
控制单元
运算单元



### 冯诺依曼模型
1. CPU (控制单元 寄存器 ALU 算术逻辑单元)
2. 存储单元
3. 输入输出设备
4. 总线



CPU：  位宽
计算 4个字节  32位cpu
计算 8个字节  64位cpu






CPU：

控制单元
计算单元

寄存器：
    通用寄存器
    特殊寄存器
    指令寄存器 PC


总线：
    地址总线
    数据总线
    控制总线

线路位宽：
电压
串行 
并行


64位 * 64


64位 寻址更宽



数据段
正文段



### 指令
    * IO类型指令
    * 计算类型指令
    * 跳转类型指令
    * 信号类型指令
    * 闲置CPU的类型指令 nop



时钟周期

64CPU 计算更大的 



### 存储器分级策略

寄存器
L1-cache (分数据和指令)
L2-cache
L3-cache
内存
硬盘/SSD


指令的预读

缓存置换


### 内核

内核是操作系统中应用连接硬件设备的桥梁



1. 管理进程，线程
2. 管理内存
3. 连接硬件设备
4. 提供系统调用




操作系统分层


ELF 
monolithic kernel
微内核


### 内核态与用户态

内存：
内核空间， 只有内核程序才能访问
用户空间， 给专门的应用程序使用



### 系统调用
权限， 

trap 执行系统调用


### 线程模型

进程：
一个应用程序启动会在内存中创建一个执行副本。



用户态线程的优势：

1. 管理开销小
2. 切换成本低


内核协作成本高
线程间协程成本高
无法利用多核优势
操作系统无法针对用户态进行优化



内核态与用户态映射关系

多对一
一对一 window
多对多 linux 
two level


### 中断



### 锁 信号量 分布式锁


原子性

竞态区

解决竞争条件
1. 互斥
2. ThreadLocal CAS指令 乐观锁



CAS指令：
原子操作
Compare and swap （cas)
作用是更新一个内存地址的值
明确要求使用者确定知道内存地址中的值是多少



TAS test -and-set 
目标是设置一个内存地址的值为1，它的工作原理和cas相似


```shell
tas(&lock) {
  return cas(&lock, 0,1)
}
```



锁：
目标是实现抢占(preempt)
只让给定数量的线程进入临界区，用tas或者cas实现。


```go
int lock = 0;
enter() {
	while(!cas(&lock, 0, 1)) {
		//
}}

leave() {
	lock = 0;
	
}


```


自旋锁

```shell
enter() {
  while (!cas(&lock, 0 , 1)) {
    //
  }
}

```

优点： 不会主动发生context switch  线程切换
缺点： 比较消耗CPU资源


wait操作

生产者消费者模型

信号量



### 分布式锁

setnx
 


同步： 
对数据的理解达到了一致

悲观锁
只有一个线程可以进入临界区互斥

乐观锁：
基于版本的控制 类似 cas


DNS:
分级缓存

去中心化：

